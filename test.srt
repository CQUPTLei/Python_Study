1
00:00:00,380 --> 00:00:02,060
这期视频我们来讲GIL啊

2
00:00:02,060 --> 00:00:05,609
GIL也就是下面的global interpreter lock

3
00:00:05,609 --> 00:00:07,229
那讲GIL之前呢

4
00:00:07,229 --> 00:00:08,909
我们首先要理清一个概念

5
00:00:08,909 --> 00:00:11,199
什么是现成线程呢

6
00:00:11,199 --> 00:00:15,430
是操作系统进行计算和调度的一个最小的单位

7
00:00:15,430 --> 00:00:17,290
我们可以简单的理解为呢

8
00:00:17,290 --> 00:00:19,810
我们的程序都是运行在县城里的

9
00:00:19,810 --> 00:00:22,689
每一个线程呢有属于自己的上下文

10
00:00:22,689 --> 00:00:26,560
那进程呢是比县城更大一点的单位

11
00:00:26,560 --> 00:00:29,560
每一个进程呢有自己的内存啊之类的

12
00:00:29,560 --> 00:00:33,370
一个进程可以有好几个县城

13
00:00:33,370 --> 00:00:37,060
这些县城呢会共享这个进程

14
00:00:37,060 --> 00:00:40,990
有的内存就是这些线程都可以读写同样的变量

15
00:00:40,990 --> 00:00:41,900
你可以这么理解

16
00:00:41,900 --> 00:00:43,400
那有关进程跟县城呢

17
00:00:43,400 --> 00:00:45,440
这是一个非常大的话题啊

18
00:00:45,440 --> 00:00:46,640
大家如果感兴趣的话

19
00:00:46,640 --> 00:00:47,420
自己去研究一下

20
00:00:47,420 --> 00:00:48,800
这不是我们今天的重点

21
00:00:48,800 --> 00:00:51,900
我们只是需要它作为一个背景资料

22
00:00:52,000 --> 00:00:55,540
那当一个进程有不止一个县城的时候呢

23
00:00:55,540 --> 00:00:56,860
就会出现一种情况

24
00:00:56,860 --> 00:00:59,060
叫做racing或者叫竞争冒险

25
00:00:59,060 --> 00:01:01,520
因为一个进程中的若干个线程呢

26
00:01:01,520 --> 00:01:03,650
他们既有可能同时运行

27
00:01:03,650 --> 00:01:05,660
也有可能交替运行

28
00:01:05,660 --> 00:01:08,830
但不管是同时运行还是交替运行

29
00:01:08,830 --> 00:01:12,370
你都没有办法控制它们之间的相对顺序

30
00:01:12,370 --> 00:01:13,330
我们举个例子

31
00:01:13,330 --> 00:01:16,920
假设两个线程都在运行左边这个函数

32
00:01:16,920 --> 00:01:18,780
我们多线程一和线程二

33
00:01:18,780 --> 00:01:21,610
假设他们两个都成功的把A初始化成一了

34
00:01:21,610 --> 00:01:22,390
注意啊

35
00:01:22,390 --> 00:01:24,490
他们两个是共享A这个变量的

36
00:01:24,490 --> 00:01:25,600
这是现成的特点

37
00:01:25,600 --> 00:01:28,570
那假设线程一先来判断这个if a大于零

38
00:01:28,570 --> 00:01:30,220
他发现这个是true

39
00:01:30,220 --> 00:01:30,790
对不对

40
00:01:30,790 --> 00:01:32,890
然后他就进入了这个if statement

41
00:01:32,890 --> 00:01:36,150
这个时候线程二开始判断了

42
00:01:36,150 --> 00:01:40,170
在线程一有能力运行A减等于一之前

43
00:01:40,170 --> 00:01:42,870
线程二也判断if a大于零

44
00:01:42,870 --> 00:01:45,570
线程二也发现11大于零

45
00:01:45,570 --> 00:01:46,050
没错

46
00:01:46,050 --> 00:01:48,610
线程二就也进这个if block了

47
00:01:48,610 --> 00:01:51,310
由于他们两个县城都进了这个if block

48
00:01:51,310 --> 00:01:53,320
所以A被减了两次

49
00:01:53,320 --> 00:01:55,420
而左边这个程序显然

50
00:01:55,420 --> 00:01:58,479
他的目的应该是把A减到零为止

51
00:01:58,479 --> 00:01:59,979
那在更多的情况下

52
00:01:59,979 --> 00:02:01,710
可能是线程一运行

53
00:02:01,710 --> 00:02:03,060
然后if a大于零

54
00:02:03,060 --> 00:02:03,720
A减等于一

55
00:02:03,720 --> 00:02:04,800
然后A就变成零了

56
00:02:04,800 --> 00:02:07,920
这个时候线程二再来判断1A大于零的时候

57
00:02:07,920 --> 00:02:09,240
他就发现A不大于零了

58
00:02:09,240 --> 00:02:11,090
然后他又跳过这if block了

59
00:02:11,090 --> 00:02:16,290
那像这种由于线程之间的相对运行顺序不同

60
00:02:16,290 --> 00:02:18,930
导致的结果不同的情况

61
00:02:18,930 --> 00:02:20,610
我们就叫做racing condition

62
00:02:20,610 --> 00:02:22,260
或者叫做竞争冒险好

63
00:02:22,260 --> 00:02:23,670
那接下来我们说回Python

64
00:02:23,670 --> 00:02:25,890
如果你学过C跟C加加的话

65
00:02:25,890 --> 00:02:27,720
你会知道在C跟C加加里面

66
00:02:27,720 --> 00:02:30,620
你是需要显示的去分配和释放内存的

67
00:02:30,620 --> 00:02:32,720
如果你光分配不释放

68
00:02:32,720 --> 00:02:34,100
随着你程序的运行

69
00:02:34,100 --> 00:02:35,900
你占用的内存就会越来越多

70
00:02:35,900 --> 00:02:37,220
你的内存就会爆炸对吧

71
00:02:37,220 --> 00:02:38,600
但是在Python里面

72
00:02:38,600 --> 00:02:42,010
你并不需要显示的去分配跟释放内存

73
00:02:42,010 --> 00:02:45,070
所有的Python object包括list diction这种东西

74
00:02:45,070 --> 00:02:46,410
你拿来直接用就可以了

75
00:02:46,410 --> 00:02:48,390
那你不用做这些烦心事

76
00:02:48,390 --> 00:02:52,540
是因为Python的解释器的memory management帮你做了这件事

77
00:02:52,540 --> 00:02:54,880
Python是怎么做到自动分配

78
00:02:54,880 --> 00:02:56,570
尤其是释放内存的呢

79
00:02:56,570 --> 00:02:57,950
为什么要说油漆呢

80
00:02:57,950 --> 00:02:59,330
因为分配比较容易对吧

81
00:02:59,330 --> 00:03:00,110
我需要内存

82
00:03:00,110 --> 00:03:01,040
我拿就行了

83
00:03:01,040 --> 00:03:02,980
关键是什么时候可以释放它

84
00:03:02,980 --> 00:03:05,950
那Python使用的机制呢叫做reference count

85
00:03:05,950 --> 00:03:07,180
引用计数

86
00:03:07,180 --> 00:03:09,040
它的原理呢也并不难理解

87
00:03:09,040 --> 00:03:14,399
就是每一个Python object他都数着有多少个地方用到了

88
00:03:14,399 --> 00:03:14,849
自己

89
00:03:14,849 --> 00:03:17,399
没有一个新的地方用到了自己

90
00:03:17,399 --> 00:03:19,370
他就把自己的引用计数加一

91
00:03:19,370 --> 00:03:20,810
然后这个地方不用了

92
00:03:20,810 --> 00:03:23,030
或者说这个object没有了

93
00:03:23,030 --> 00:03:24,750
我的引用计数就减一

94
00:03:24,750 --> 00:03:26,910
这样只要你数数数的是对的

95
00:03:26,910 --> 00:03:30,150
我就可以知道什么时候我的引用计数到零了

96
00:03:30,150 --> 00:03:31,350
那就没有人需要我了

97
00:03:31,350 --> 00:03:33,650
我自己呢就可以帮助我这块内存释放掉了

98
00:03:33,650 --> 00:03:36,050
大家可以看这里这个up ref count

99
00:03:36,050 --> 00:03:39,610
就是这个拍object的引用计数保存的地方

100
00:03:39,610 --> 00:03:43,330
这里这个拍decrease rap函数也是比较好读啊

101
00:03:43,330 --> 00:03:45,780
就是把这个raf camp减一

102
00:03:45,780 --> 00:03:47,880
然后如果它到零了的话

103
00:03:47,880 --> 00:03:49,450
就把它DEALLOCATE掉

104
00:03:49,450 --> 00:03:51,190
这个事情本身不难理解对吧

105
00:03:51,190 --> 00:03:52,030
就是数数嘛

106
00:03:52,030 --> 00:03:56,260
但是结合我们刚才说的那个竞争冒险的事情

107
00:03:56,260 --> 00:03:57,579
我们可以想一下

108
00:03:57,579 --> 00:04:01,479
如果一个进程里有多线程在运行的话

109
00:04:01,479 --> 00:04:04,470
这里就会有一个竞争冒险的问题

110
00:04:04,470 --> 00:04:07,710
因为这个减减of breath count

111
00:04:07,710 --> 00:04:09,570
它并不是atomic

112
00:04:09,570 --> 00:04:10,350
Atomic

113
00:04:10,350 --> 00:04:10,770
意思呢

114
00:04:10,770 --> 00:04:13,589
就是说我在运行的时候不会被其他的线程打断

115
00:04:13,589 --> 00:04:16,738
这个减减虽然在C里面看起来像是一个操作符

116
00:04:16,738 --> 00:04:20,180
但它实际上也要把这个recount的信息读出来

117
00:04:20,180 --> 00:04:22,130
减一再存回去

118
00:04:22,130 --> 00:04:23,750
那在这三个步骤中间

119
00:04:23,750 --> 00:04:26,060
就有可能有其他的县城过来

120
00:04:26,060 --> 00:04:29,770
在你存回去之前也做这件事儿

121
00:04:29,770 --> 00:04:33,250
那这种情况的发生就有可能让你数数数错了

122
00:04:33,250 --> 00:04:34,270
多数了一个呀

123
00:04:34,270 --> 00:04:35,050
少数了一个呀

124
00:04:35,050 --> 00:04:36,080
这都是有可能的

125
00:04:36,080 --> 00:04:38,780
那一旦你数数数不明白了

126
00:04:38,780 --> 00:04:40,520
是不是你就没有办法保证

127
00:04:40,520 --> 00:04:43,789
你的每一个Python objects都可以正确的被释放了

128
00:04:43,789 --> 00:04:46,169
那你就会出现非常严重没内存泄露的问题

129
00:04:46,169 --> 00:04:49,859
那在县城中一般来说是怎么解决这个问题的呢

130
00:04:49,859 --> 00:04:52,039
最常用的方法叫做枷锁

131
00:04:52,039 --> 00:04:53,569
枷锁是什么意思呢

132
00:04:53,569 --> 00:04:56,449
就是我要保证这一段程序

133
00:04:56,449 --> 00:04:59,659
只有我一个线程在运行

134
00:04:59,659 --> 00:05:02,840
其他的县城不可以进入这段程序

135
00:05:02,840 --> 00:05:03,980
你可以理解为对吧

136
00:05:03,980 --> 00:05:05,720
你上厕所的时候有一个隔间

137
00:05:05,720 --> 00:05:06,260
你进去之后

138
00:05:06,260 --> 00:05:07,310
你先把门插上

139
00:05:07,310 --> 00:05:08,480
然后你在里面干什么事

140
00:05:08,480 --> 00:05:10,630
别管剩下的人想进这个门

141
00:05:10,630 --> 00:05:11,470
要先排队

142
00:05:11,470 --> 00:05:12,790
等你出来之后

143
00:05:12,790 --> 00:05:13,670
他才能进去

144
00:05:13,670 --> 00:05:15,590
那通过锁这个机制呢

145
00:05:15,590 --> 00:05:18,020
它就可以解决这种竞争冒险的问题

146
00:05:18,020 --> 00:05:20,300
那我左边给出的是一个伪代码啊

147
00:05:20,300 --> 00:05:22,280
我没有给出来一个能运行的

148
00:05:22,280 --> 00:05:23,600
这个multi spreading的程序员

149
00:05:23,600 --> 00:05:24,770
大家理解一下就行

150
00:05:24,770 --> 00:05:26,690
就是在这个if之前

151
00:05:26,690 --> 00:05:28,440
我先锁住它

152
00:05:28,440 --> 00:05:30,720
这样我在运行if a大于零

153
00:05:30,720 --> 00:05:32,299
A减等一的时候

154
00:05:32,299 --> 00:05:37,039
其他的线程是不能进入到这个代码之内的

155
00:05:37,039 --> 00:05:39,619
他们需要等我release了这个lock之后

156
00:05:39,619 --> 00:05:41,440
他才能再运行这段程序

157
00:05:41,440 --> 00:05:42,880
那让我们回到Python

158
00:05:42,880 --> 00:05:44,440
这个时候你肯定说哎这个简单对不对

159
00:05:44,440 --> 00:05:47,630
我只需要在这个if外面加一个锁就可以了

160
00:05:47,630 --> 00:05:52,350
但是啊Python不光是这个reference count有这个问题

161
00:05:52,350 --> 00:05:55,110
它所有跟Python object有关的代码

162
00:05:55,110 --> 00:05:56,710
都有可能会存在这个问题

163
00:05:56,710 --> 00:06:01,000
都有可能有若干个线程同时尝试去读

164
00:06:01,000 --> 00:06:03,919
或者写这个Python objects的数据

165
00:06:03,919 --> 00:06:08,479
所以说当时设计Python的这些设计者们

166
00:06:08,479 --> 00:06:12,750
决定给Python设计一个全局的所

167
00:06:12,750 --> 00:06:14,910
也就是我们所谓的GIL

168
00:06:14,910 --> 00:06:17,490
GIL那1430行

169
00:06:17,490 --> 00:06:21,450
这行代码呢是在我们之前提到过的C1while

170
00:06:21,450 --> 00:06:23,680
点C里面那个main loop里面

171
00:06:23,680 --> 00:06:27,250
它的作用就是拿到这个global锁

172
00:06:27,250 --> 00:06:29,660
我们可以进去看一下这个函数里面

173
00:06:29,660 --> 00:06:30,320
就是这样的啊

174
00:06:30,320 --> 00:06:32,180
如果他收到了drop的信息的话

175
00:06:32,180 --> 00:06:32,900
他会先drop

176
00:06:32,900 --> 00:06:36,430
然后take这个函数可以保证在它运行完之后

177
00:06:36,430 --> 00:06:40,369
当前的这个线程会拿到GIL所

178
00:06:40,369 --> 00:06:42,259
那通过这种机制

179
00:06:42,259 --> 00:06:45,930
Python可以保证每一个bite code

180
00:06:45,930 --> 00:06:50,230
在运行的时候都是拿到线程锁的

181
00:06:50,230 --> 00:06:51,310
换言之

182
00:06:51,310 --> 00:06:55,690
没有bad code可以被其他的线程所打断

183
00:06:55,690 --> 00:06:56,770
这样的话

184
00:06:56,770 --> 00:07:00,580
你在每一个by code里面运行的C程序

185
00:07:00,580 --> 00:07:02,320
就都是线程安全的

186
00:07:02,320 --> 00:07:05,810
你可以在里面大胆的去增加reference count啊

187
00:07:05,810 --> 00:07:06,950
减少reference count

188
00:07:06,950 --> 00:07:08,210
你都不用管锁的事

189
00:07:08,210 --> 00:07:10,770
因为你已经知道锁被拿住了

190
00:07:10,770 --> 00:07:13,860
那这种全局所有什么好处呢

191
00:07:13,860 --> 00:07:15,400
好处还是非常多的

192
00:07:15,400 --> 00:07:17,800
你们可能经常会看到很多人诟病说

193
00:07:17,800 --> 00:07:18,940
这个Python的GIL呢

194
00:07:18,940 --> 00:07:22,300
是这个阻止Python前进的这么一个桎梏

195
00:07:22,300 --> 00:07:25,060
但是他最开始三个设计绝对是有它的初衷的

196
00:07:25,060 --> 00:07:26,050
它的好处非常多

197
00:07:26,050 --> 00:07:28,870
第一这是一个非常简单的设计

198
00:07:28,870 --> 00:07:30,670
你如果真正写比较大的项目

199
00:07:30,670 --> 00:07:33,280
就知道简单真的是一个很重要的事儿

200
00:07:33,280 --> 00:07:34,780
越简单的程序

201
00:07:34,780 --> 00:07:35,800
你越有可能写

202
00:07:35,800 --> 00:07:38,549
对你在维护上所需要的努力就越小

203
00:07:38,549 --> 00:07:40,980
而这种全局锁相对

204
00:07:40,980 --> 00:07:44,880
对于你可能每一个object都实现一个自己的锁

205
00:07:44,880 --> 00:07:46,580
要简单非常多

206
00:07:46,580 --> 00:07:49,100
第二由于只有一个线程所

207
00:07:49,100 --> 00:07:50,670
他避免了死锁的问题

208
00:07:50,670 --> 00:07:51,570
死锁是什么呢

209
00:07:51,570 --> 00:07:53,310
我们在这里也不过多的介绍啊

210
00:07:53,310 --> 00:07:54,210
但是你只需要知道

211
00:07:54,210 --> 00:07:56,430
当你一个县城里面有两个以上的锁的时候

212
00:07:56,430 --> 00:07:58,400
它就有可能会造成死锁

213
00:07:58,400 --> 00:08:00,740
第三对于单线程的程序

214
00:08:00,740 --> 00:08:04,310
或者是没法并行的多线程程序

215
00:08:04,310 --> 00:08:07,250
这种全局锁的性能是非常优秀的

216
00:08:07,250 --> 00:08:09,770
大家可以想到这个要锁这件事

217
00:08:09,770 --> 00:08:11,960
显然是需要一些时间成本对吧

218
00:08:11,960 --> 00:08:14,240
那全局锁就保证了

219
00:08:14,240 --> 00:08:17,540
你在每一次运行一个bad code的时候

220
00:08:17,540 --> 00:08:19,679
至多只需要要一次锁

221
00:08:19,679 --> 00:08:20,759
但是如果你是那种

222
00:08:20,759 --> 00:08:22,739
比如每一个object都有自己的锁的话

223
00:08:22,739 --> 00:08:26,099
你一个BO由于你要access很多个object

224
00:08:26,099 --> 00:08:27,930
你就可能要拿很多次锁

225
00:08:27,930 --> 00:08:31,650
最后呢就是他让你给这个Python代码

226
00:08:31,650 --> 00:08:34,260
而写c extension变得容易了很多

227
00:08:34,260 --> 00:08:37,909
因为你可以确定在每一个by code运行的时候

228
00:08:37,909 --> 00:08:40,068
没有现成的竞争冒险问题

229
00:08:40,068 --> 00:08:43,549
这样你在你的C代码里面去修改Python object的时候

230
00:08:43,549 --> 00:08:45,720
你就不用管那些乱七八糟的锁

231
00:08:45,720 --> 00:08:49,060
让这个第三方开发者的编程变得容易了很多

232
00:08:49,060 --> 00:08:51,580
那其实有人说Python能有今天的成绩

233
00:08:51,580 --> 00:08:54,430
跟他的c extension开发比较容易

234
00:08:54,430 --> 00:08:56,040
也是有密切的关系的

235
00:08:56,040 --> 00:08:58,170
那以上种种的优势

236
00:08:58,170 --> 00:09:01,430
就是至今GIL仍然存在在Python里的原因

237
00:09:01,430 --> 00:09:02,510
古往今来呢

238
00:09:02,510 --> 00:09:05,690
也不是没有人尝试从Python里面拿走GIL

239
00:09:05,690 --> 00:09:11,120
但是没有一次尝试是可以保证Python在单线程

240
00:09:11,120 --> 00:09:14,609
单线程下的运行速度不受到影响的

241
00:09:14,609 --> 00:09:15,329
当然了

242
00:09:15,329 --> 00:09:16,769
还有一个非常严重的问题

243
00:09:16,769 --> 00:09:18,839
就是所谓的backward compatibility

244
00:09:18,839 --> 00:09:20,300
也就是所谓向后兼容

245
00:09:20,300 --> 00:09:22,340
就是我之前写的c extension

246
00:09:22,340 --> 00:09:24,410
都默认我现在是有线程锁的

247
00:09:24,410 --> 00:09:25,640
你现在把这个东西拿掉了

248
00:09:25,640 --> 00:09:27,349
那我那个东西很有可能就不好使了

249
00:09:27,349 --> 00:09:30,469
好那我们说了这个GIL天使的一面

250
00:09:30,469 --> 00:09:32,269
那他被这么多人诟病

251
00:09:32,269 --> 00:09:33,649
他自然有恶魔的一面

252
00:09:33,649 --> 00:09:34,180
对吧

253
00:09:34,180 --> 00:09:35,200
我们就来说说

254
00:09:35,200 --> 00:09:38,610
GIL给Python带来了很严重的一个问题

255
00:09:38,610 --> 00:09:40,230
那在说这个问题之前呢

256
00:09:40,230 --> 00:09:42,460
我们首先要回顾一下Python的历史

257
00:09:42,460 --> 00:09:45,640
很多人会觉得Python是一个比较新兴的语言

258
00:09:45,640 --> 00:09:47,650
其实Python比java还要大

259
00:09:47,650 --> 00:09:51,000
他是上个世纪90年代初期被开发出来的

260
00:09:51,000 --> 00:09:52,470
在那个年代呢

261
00:09:52,470 --> 00:09:54,980
多核这种东西啊几乎不存在

262
00:09:54,980 --> 00:09:56,480
多线程存在的意义

263
00:09:56,480 --> 00:09:58,960
就是这些线程可以轮流执行

264
00:09:58,960 --> 00:10:02,200
不会因为某一个线程计算量过大而卡住了

265
00:10:02,200 --> 00:10:03,010
其他的事情

266
00:10:03,010 --> 00:10:05,089
它就是一个切片并行的理念

267
00:10:05,089 --> 00:10:06,169
所以在那个年代呢

268
00:10:06,169 --> 00:10:07,789
他本来就只有一块CPU

269
00:10:07,789 --> 00:10:10,129
本来就只能运行一个线程的代码

270
00:10:10,129 --> 00:10:13,670
所以这个global的interpret lock呢没什么影响

271
00:10:13,670 --> 00:10:16,760
但是啊进入了21世纪之后呢

272
00:10:16,760 --> 00:10:19,170
多核现在已经是电脑的标配了

273
00:10:19,170 --> 00:10:21,750
就每一个电脑都有很多个CPU核心

274
00:10:21,750 --> 00:10:24,110
然后他们可以同时进行计算

275
00:10:24,110 --> 00:10:26,630
也就是说一个进程的若单线程

276
00:10:26,630 --> 00:10:30,500
可以同时在若干个CPU和上一起跑

277
00:10:30,500 --> 00:10:35,420
通过这种并行来增加你程序运行的速度

278
00:10:35,420 --> 00:10:37,220
我本来要算100个数对吧

279
00:10:37,220 --> 00:10:38,410
但是我有四个CPU

280
00:10:38,410 --> 00:10:40,420
我让每个CPU算25个数

281
00:10:40,420 --> 00:10:41,590
这不速度成了四吗

282
00:10:41,590 --> 00:10:42,850
那在这种情况下

283
00:10:42,850 --> 00:10:44,910
GIL就出现了严重的水土不服

284
00:10:44,910 --> 00:10:48,810
因为它每一个interpreter只允许一个线程运行

285
00:10:48,810 --> 00:10:49,710
它的by code

286
00:10:49,710 --> 00:10:51,510
所以说你不管有多少个线程

287
00:10:51,510 --> 00:10:54,680
只能有一个线程在实际的运行Python代码

288
00:10:54,680 --> 00:10:57,200
这就导致了Python的多线程

289
00:10:57,200 --> 00:11:01,690
没有办法利用多核来增加自己的运算速度

290
00:11:01,690 --> 00:11:04,030
那这个问题呢在Python刚被发明的时候

291
00:11:04,030 --> 00:11:05,050
它不是一个问题

292
00:11:05,050 --> 00:11:06,250
但是到现在来了

293
00:11:06,250 --> 00:11:07,870
它变成了一个大问题啊

294
00:11:07,870 --> 00:11:08,890
这就是时代的改变

295
00:11:08,890 --> 00:11:10,130
对语言造成的影响

296
00:11:10,130 --> 00:11:14,170
那Python在这个多核CPU时代就一无是处了吗

297
00:11:14,170 --> 00:11:15,490
显然不是啊

298
00:11:15,490 --> 00:11:17,200
Python依然是生机勃勃的

299
00:11:17,200 --> 00:11:18,010
为什么呢

300
00:11:18,010 --> 00:11:21,480
因为Python有其他的方式来避开这个计算机问题

301
00:11:21,480 --> 00:11:25,710
那相对来说最简单也最Python的呢就是用multi processing

302
00:11:25,710 --> 00:11:28,679
也就是用多进程来解决这个问题

303
00:11:28,679 --> 00:11:32,459
就虽然你一个进程没有办法利用多个CPU

304
00:11:32,459 --> 00:11:34,360
但是我可以有好多个进程啊

305
00:11:34,360 --> 00:11:37,840
使用多进程就可以避开GIL这个问题

306
00:11:37,840 --> 00:11:40,920
然后利用多核的CPU给自己的程序加速

307
00:11:40,920 --> 00:11:45,450
那第二种方式呢是你可以通过自己写c extension

308
00:11:45,450 --> 00:11:48,390
然后在C里面去做多线程

309
00:11:48,390 --> 00:11:51,390
就是你的多线程是运行的C代码

310
00:11:51,390 --> 00:11:52,650
而不是Python代码

311
00:11:52,650 --> 00:11:53,310
当然了

312
00:11:53,310 --> 00:11:56,220
你就要自己去解决那边的这个竞争冒险问题

313
00:11:56,220 --> 00:12:02,890
包括如果你多个C线程同时尝试access Python object的话

314
00:12:02,890 --> 00:12:04,270
你就要更小心一点

315
00:12:04,270 --> 00:12:05,140
那当然了

316
00:12:05,140 --> 00:12:10,329
你也可以尝试用一些没有GIL的Python解释器

317
00:12:10,329 --> 00:12:13,269
这个事我们在之前的某一期视频也提到过

318
00:12:13,269 --> 00:12:14,769
像JON啊

319
00:12:14,769 --> 00:12:15,969
包括iron Python啊

320
00:12:15,969 --> 00:12:17,739
好像都是没有GIL的

321
00:12:17,739 --> 00:12:19,940
但是拍派是有的好

322
00:12:19,940 --> 00:12:22,040
那这期视频简单的跟大家介绍一下GIL啊

323
00:12:22,040 --> 00:12:23,180
希望对大家有所帮助

324
00:12:23,180 --> 00:12:23,960
如果你喜欢的话

325
00:12:23,960 --> 00:12:24,980
别忘了点一下关注

326
00:12:24,980 --> 00:12:25,780
记得一键三连哦

